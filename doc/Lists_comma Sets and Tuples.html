<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="doc.css" media="all">
		<title>
			claire : Lists, Sets and Tuples
		</title>
		<style>
body {
        font-size: 14px;
        font-family: arial, Helvetica;
}

h1 { font-size: 25px; }
h2 { font-size: 20px; }

a[href] {
	border-bottom: 1px dotted grey;
	text-decoration: none
}

.doc_paragraph
{
        font-size: 14px;
        font-family: arial, helvetica;
}

.item_header { font-size: 10px; page-break-before: avoid; page-break-inside: avoid; page-break-after: avoid }

.item_index {
		white-space: pre;
        font-size: 11px;
        font-family: monaco, courier, mono-space;
}

.table_code {
		margin: 10px auto;
}

.doc_code {
    white-space: pre;
		padding-top: .1em;
		padding-bottom: .5em;
		background-color: #EEE;
		border: #AAA solid 1px;
        font-size: 11px;
        font-family: monaco, courier, mono-space;
}

.opt_usage {
		margin-left: 1em;
		margin-right: 1em;
		padding: .2em;
		background-color: #EEE;
		border: #AAA solid 1px;
        font-family: monaco, courier, mono-space;
	
}

.class_proto {
	vertical-align: top;
	text-align: right;
}

.class_proto_super {
	vertical-align: top;
	text-align: right;
}

.class_proto_slot {
	vertical-align: top;
	text-align: left;
}

</style>
	</head>
	<body><table width='100%' class='item_header'>
		<tr>
			<td width='33%' align='left' valign='bottom'><i>Objects, Classes and Slots<br/><a href='Updates.html#4611703575761505714'>Updates</a></i></td>
			<td width='33%' align='center' valign='top'><i><a href='claire.index.html#__category_index__'>categories</a><br/><a href='claire.index.html#4611703575761536242'>Lists, Sets and Instructions</a><br/><b>Lists, Sets and Tuples</b>
				</i></td>
			<td width='33%' align='right' valign='bottom'><i><a href='Blocks.html#4611703575761540002'>Blocks</a></i></td>
		</tr>
	</table>
	<h1><span class=pretitle>&nbsp;</span>&nbsp;Lists, Sets and Instructions</h1>
		<h2><span class=pretitle>&nbsp;</span>&nbsp;<a name='4611703575761536226'>Lists, Sets and Tuples</a>
			</h2>
	<ul></ul><ul><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400226'>/+</a>(<font color='green'>x</font><font color='blue'>:</font>bag, <font color='green'>y</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763200018'>/+</a>(<font color='green'>l1</font><font color='blue'>:</font>list, <font color='green'>l2</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763201106'>&lt;&lt;</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>n</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763199074'>^</a>(<font color='green'>s1</font><font color='blue'>:</font>set, <font color='green'>s2</font><font color='blue'>:</font>set)<font color='blue'> -&gt; </font>set</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763198706'>^</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>y</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763159746'>add</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763159682'>add</a>(<font color='green'>s</font><font color='blue'>:</font>set, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>set</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763159938'>add*</a>(<font color='green'>l1</font><font color='blue'>:</font>list, <font color='green'>l2</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400706'>car</a>(<font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>any</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763162418'>cast!</a>(<font color='green'>s</font><font color='blue'>:</font>bag, <font color='green'>t</font><font color='blue'>:</font>type)<font color='blue'> -&gt; </font>bag</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763162066'>cdr</a>(<font color='green'>l</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>type[l]</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763163778'>cons</a>(<font color='green'>x</font><font color='blue'>:</font>any, <font color='green'>l</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763163954'>copy</a>(<font color='green'>s</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>bag</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763164978'>delete</a>(<font color='green'>s</font><font color='blue'>:</font>bag, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>bag</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400914'>difference</a>(<font color='green'>self</font><font color='blue'>:</font>set, <font color='green'>x</font><font color='blue'>:</font>set)<font color='blue'> -&gt; </font>set</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763175538'>get</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>integer</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763176034'>hash</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>integer</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400274'>last</a>(<font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>type[member(self)]</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763399586'>length</a>(<font color='green'>self</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>integer</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763178866'>list!</a>(<font color='green'>s</font><font color='blue'>:</font>set)<font color='blue'> -&gt; </font>type[list[member(s)]]</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763179506'>make_list</a>(<font color='green'>t</font><font color='blue'>:</font>type, <font color='green'>n</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list <font color='red'>[XL]</font></font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763179426'>make_list</a>(<font color='green'>n</font><font color='blue'>:</font>integer, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>type[list[list&lt;any&gt;(x),list({})]]</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763399954'>max</a>(<font color='green'>f</font><font color='blue'>:</font>method, <font color='green'>self</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>type[member(self)]</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763399874'>min</a>(<font color='green'>f</font><font color='blue'>:</font>method, <font color='green'>self</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>type[member(self)]</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763321282'>nil</a><font color='blue'> :: </font>Id(nil)</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763157970'>nth</a><font color='blue'> :: </font>property(open = 3)</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763183202'>nth</a>(<font color='green'>l</font><font color='blue'>:</font>bag, <font color='green'>i</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>any</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763183762'>nth+</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>i</font><font color='blue'>:</font>integer, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>bag</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763184034'>nth-</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>i</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>bag</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400402'>nth=</a>(<font color='green'>self</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>integer, <font color='green'>y</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>any</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763159010'>nth=</a><font color='blue'> :: </font>property(open = 3)</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400338'>rmlast</a>(<font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763190258'>shrink</a>(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>n</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763183250'>sort</a>(<font color='green'>f</font><font color='blue'>:</font>method, <font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</font></li><li><font font-face='Courier' class='item_index'><a href='Lists_comma Sets and Tuples.html#4611703575763400834'>tuple!</a>(<font color='green'>x</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>tuple</font></li></ul><p align='justify' class='doc_paragraph'> CLAIRE provides two easy means of manipulating collections of <a href='Objects and Entities.html#4611703575761306018'><font color='#'>objects</font></a>: sets and lists.
 Lists are ordered, possibly heterogeneous, collections. To create a list, one must use
 the list(...) instruction&nbsp;: it admits any <a href='Integers and Floats.html#4611703575761301906'><font color='#'>number</font></a> of arguments and returns the list of its
 arguments. Each argument to the list(...) constructor is evaluated.</p><p align='justify' class='doc_paragraph'> </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> list(a, b, c, d) list(1, 2 + 3), list()
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> Sets are collections without order and without duplicates. Sets are created similarly
 with the set(...) constructor&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> set(a,b,c) set(1,2 + 3)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> The major novelty in CLAIRE 3.2 is the fact that lists or sets may be typed. This means
 that each bag (set or list) may have a <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> <a href='Calls and Slot Access.html#4611703575761501330'><font color='#'>slot</font></a> named of, which contains a <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> to which
 all members of the list must belong. This <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> is optional, as is illustrated by the previous
 examples, where no typing was given for the lists or sets. To designate a <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> for a <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> list
 or a <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> set, we use a slightly different syntax&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> list&lt;thing&gt;(a,b,c,d) list&lt;integer&gt;(1,2 + 3) list&lt;float&gt;()
 set&lt;thing&gt;(a,b,c) set&lt;integer&gt;(1, 2 + 3)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> Typing a list or a set is a way to ensure that adding <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> values to them will <a href='Objects and Entities.html#4611703575763393826'><font color='#'>not</font></a> violate
 typing assumptions, which could happen in earlier versions of CLAIRE. Insertion is now always
 a destructive <a href='Selectors_comma Properties and Operations.html#4611703575762381458'><font color='#'>operation</font></a> (<a href='Classes.html#4611703575763256562'><font color='#'>add</font></a>(l,x) returns the list l, that has been augmented with the value x
 at its <a href='Modules.html#4611703575763160370'><font color='#'>end</font></a>).</p><p align='justify' class='doc_paragraph'> Since typing is mandatory in order to assume type-safe <a href='Updates.html#4611703575761505714'><font color='#'>updates</font></a> onto a list or a set, if no
 <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> is provided, CLAIRE will forbid any future <a href='Updates.html#4611703575761505714'><font color='#'>update</font></a>: the list or the set is then a "read-only"
 structure. This is the major novelty in CLAIRE 3.2: there is a <a href='Lists_comma Sets and Tuples.html#4611703575763400914'><font color='#'>difference</font></a> between:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> list(a,b,c,d) set(1,2 + 3) list{i | i in (1 .. 2)}
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> which are read-only structures, and&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> list&lt;thing&gt;(a, b) set&lt;integer&gt;(1, 2 + 3)
 list&lt;integer&gt;{i | i in (1 .. 2)}
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> which are structures that can be updated.</p><p align='justify' class='doc_paragraph'> List or set <a href='Types.html#4611703575761920178'><font color='#'>types</font></a> can be arbitrarily complex, to represent complex list <a href='Types.html#4611703575761920178'><font color='#'>types</font></a> such as
 list of lists of <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integers</font></a>. However, it is recommended to use a <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>global</font></a> <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>constant</font></a>
 to represent a complex <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> that is used as a list <a href='Types.html#4611703575761920178'><font color='#'>type</font></a>, as follows&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> MyList&nbsp;:: list&lt;integer&gt;
 set&lt;MyList&gt;(list&lt;integer&gt;(1), list&lt;integer&gt;(2, 3))
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>Constant</font></a> sets are valid CLAIRE <a href='Types.html#4611703575761920178'><font color='#'>types</font></a> and can be built using the following syntax&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> {a,b,c,d} {3, 8}
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> The expressions inside a <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>constant</font></a> set expression are <a href='Objects and Entities.html#4611703575763393826'><font color='#'>not</font></a> evaluated and should be primitive
 <a href='Objects and Entities.html#4611703575761306018'><font color='#'>entities</font></a>, such as <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integers</font></a> or <a href='Strings.html#4611703575761305618'><font color='#'>strings</font></a>, named <a href='Objects and Entities.html#4611703575761306018'><font color='#'>objects</font></a> or <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>global</font></a> <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>constants</font></a>. <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>Constant</font></a> sets are
 <a href='Global Variables and Constants.html#4611703575763056690'><font color='#'>constant</font></a>, which means that inserting a <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> value is forbidden and will provoke an <a href='Exception Handling.html#4611703575761850354'><font color='#'>error</font></a>.</p><p align='justify' class='doc_paragraph'> A set can also be formed by selection. The result can either be a set with {x in a | P(x)}, or
 a list with list{x in a | P(x)}, when one wants to preserve the order of a and keep the duplicates
 if a was a list. Similarly, one may decide to create a typed or an un-typed list or set, by adding
 the additional <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> information between angular brackets. For instance, here are two samples with
 and without typing&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> {x in <a href='Classes.html#4611703575761317538'><font color='#'>class</font></a> | (thing <a href='Types.html#4611703575763199298'><font color='#'>%</font></a> x.ancestors)}
 list{x in (0 .. 14) | x <a href='Integers and Floats.html#4611703575763183010'><font color='#'>mod</font></a> 2 = 0}
 set&lt;class&gt;{x in <a href='Classes.html#4611703575761317538'><font color='#'>class</font></a> | (thing <a href='Types.html#4611703575763199298'><font color='#'>%</font></a> x.ancestors)}
 list&lt;integer&gt;{x in (0 .. 14) | x <a href='Integers and Floats.html#4611703575763183010'><font color='#'>mod</font></a> 2 = 0}
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> When does one need to <a href='Classes.html#4611703575763256562'><font color='#'>add</font></a> typing information to a list or a set ? A <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> is needed when <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a>
 insertions need to be made, for instance when the list or set is meant to be stored in an
 <a href='Objects and Entities.html#4611703575761306018'><font color='#'>object</font></a>'s <a href='Calls and Slot Access.html#4611703575761501330'><font color='#'>slot</font></a> which is itself typed.</p><p align='justify' class='doc_paragraph'> Also, the imageof a set via a function can be formed. Here again, the result can either be a set
 with {f(x)|x in a} or a list with list{f(x) | x in a}, when one wants to preserve the order of a
 and the duplicates&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> {(x <a href='Integers and Floats.html#4611703575763398626'><font color='#'>^</font></a> 2) | x in (0 .. 10)}
 list&lt;integer&gt;{size(x.<a href='Calls and Slot Access.html#4611703575761501330'><font color='#'>slots</font></a>) | x in <a href='Classes.html#4611703575761317538'><font color='#'>class</font></a>}
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> For example, we have the traditional average_salary <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a>&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> average_salary(s:set[man])&nbsp;: <a href='Integers and Floats.html#4611703575761301906'><font color='#'>float</font></a>
 	-&gt; (sum(list{m.sal | m in s}) / size(s))
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> <a href='Lists_comma Sets and Tuples.html#4611703575763400274'><font color='#'>Last</font></a>, two usual constructions are offered in CLAIRE to check a boolean expression universally
 (forall) or existentially (exists). A <a href='Types.html#4611703575763317762'><font color='#'>member</font></a> of a set that satisfies a condition can be extracted
 (a non-deterministic <a href='Hypothetical Reasoning.html#4611703575763198162'><font color='#'>choice</font></a>) using the some construct: some(x in a | f(x)). For instance, we can <a href='Classes.html#4611703575763256482'><font color='#'>write</font></a>&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> exists(x in (1 .. 10) | x &gt; 2) // returns true
 some(x in (1 .. 10) | x &gt; 2) // returns 3 in most implementations
 exists(x in <a href='Classes.html#4611703575761317538'><font color='#'>class</font></a> | <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>(x.ancestors) &gt; 10)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> The <a href='Lists_comma Sets and Tuples.html#4611703575763400914'><font color='#'>difference</font></a> between exists and some is that the first always returns a boolean, whereas the
 second returns one of the <a href='Objects and Entities.html#4611703575761306018'><font color='#'>objects</font></a> that satisfy the condition (if there exists one) and unknown
 otherwise. It is very often used in conjunction with when, as in the following example&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> when x&nbsp;:= some(x in man | rich?(x))
 in (borrow_from(x,1000), ...)
 else printf("There is no one from whom to borrow!")
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> Conversely, the boolean expression forall(x in a | f(x)) returns true if and only if f(x) is
 true for all members of the set a. The two following examples returns false (because of 1):
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> forall(x in (1 .. 10) | x &gt; 2)
 forall(x in (1 .. n) | exists(y in (1 .. x) | y * y &gt; x))
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> </p>
									<table align='center' width='80%'>
									<tr><td><p align='justify' class='doc_paragraph'>
										<b>Definition : </b><i>A list is an ordered collection of <a href='Objects and Entities.html#4611703575761306018'><font color='#'>objects</font></a> that is organized into an extensible <a href='array.html#4611703575761883778'><font color='#'>array</font></a>,
 with an indexed access to its members. A list may contain duplicates, which are multiple
 <a href='Strings.html#4611703575763184434'><font color='#'>occurrence</font></a> of the same <a href='Objects and Entities.html#4611703575761306018'><font color='#'>object</font></a>. A set is a collection of <a href='Objects and Entities.html#4611703575761306018'><font color='#'>objects</font></a> without duplicates and without
 any user-defined order. The existence of a system-dependent order is language-dependent and
 should <a href='Objects and Entities.html#4611703575763393826'><font color='#'>not</font></a> be abused. The concept of bag in CLAIRE is the unifier between lists and sets&nbsp;: a
 collection of <a href='Objects and Entities.html#4611703575761306018'><font color='#'>objects</font></a> with possible duplicates and without order. </i></p></td></tr></table>
									<p align='justify' class='doc_paragraph'> A read-only (untyped) list can also be thought as tuples of values. For upward compatibility reasons,
 the expression tuple(a1,...,an) is equivalent to list(a1,...,an)&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> tuple(1,2,3), tuple(1,2.0,"this is heterogeneous")
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> Since it is a read-only list, a tuple cannot be changed once it is created, neither through addition
 of a <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> <a href='Types.html#4611703575763317762'><font color='#'>member</font></a> (using the <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> <a href='Classes.html#4611703575763256562'><font color='#'>add</font></a>) or through the exchange of a given <a href='Types.html#4611703575763317762'><font color='#'>member</font></a> (using the <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>=
 <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a>). CLAIRE offers an associated data <a href='Types.html#4611703575761920178'><font color='#'>type</font></a>. For instance, the
 following expressions are true&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> tuple(1,2,3) <a href='Types.html#4611703575763199298'><font color='#'>%</font></a> tuple(<a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a>,<a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a>,<a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a>)
 tuple(1,2,3) <a href='Types.html#4611703575763199298'><font color='#'>%</font></a> tuple(0 .. 1, 0 .. 10, 0 .. 100)
 tuple(1,2.0,"this is heterogeneous") <a href='Types.html#4611703575763199298'><font color='#'>%</font></a> tuple(any,any,any)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'> Typed tuples are used to return multiple values from a <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a>. Because a tuple
 is a bag, it supports membership, iteration and indexed access <a href='Selectors_comma Properties and Operations.html#4611703575762381458'><font color='#'>operations</font></a>. However, there is yet
 another data structure in CLAIRE for homogeneous <a href='array.html#4611703575761883778'><font color='#'>arrays</font></a> of fixed <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>, called <a href='array.html#4611703575761883778'><font color='#'>arrays</font></a>. <a href='array.html#4611703575761883778'><font color='#'>Arrays</font></a> are
 similar to lists but their size is fixed once they are created and they must be assigned a subtype
 (a <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> for the members of the <a href='array.html#4611703575761883778'><font color='#'>array</font></a>) that cannot change. Because of these strong constraints,
 CLAIRE can provide an implementation that is more efficient (memory usage and access <a href='Dates and Times.html#4611703575761303426'><font color='#'>time</font></a>) than
 the implementation of bags. However, the use of <a href='array.html#4611703575761883778'><font color='#'>arrays</font></a> is considered an advanced feature of CLAIRE
 since everything that is done with an <a href='array.html#4611703575761883778'><font color='#'>array</font></a> may also be done with a list.</p><a name='4611703575763400226'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='/+'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>/+(<font color='green'>x</font><font color='blue'>:</font>bag, <font color='green'>y</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> <b>x</b> /+ <b>y</b> returns a <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> that is the concatenation of the two <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> contents.</p><a name='4611703575763200018'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='/+'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>/+(<font color='green'>l1</font><font color='blue'>:</font>list, <font color='green'>l2</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> <b>l1</b> /+ <b>l2</b> returns a <a href='Classes.html#4611703575763395122'><font color='#'>new</font></a> <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> that is the concatenation of the two <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>lists</font></a>.</p><a name='4611703575763201106'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='<<'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>&lt;&lt;(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>n</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> (<b>l</b> &lt;&lt; <b>n</b>) left-shifts the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l</b> by <b>n</b> units, which means that the <b>n</b> first
 members of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> are removed. This is a <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> with a side-effect since
 the returned value is the original <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>, which has been modified.</p><a name='4611703575763199074'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='^'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>^(<font color='green'>s1</font><font color='blue'>:</font>set, <font color='green'>s2</font><font color='blue'>:</font>set)<font color='blue'> -&gt; </font>set</h3><p align='justify' class='doc_paragraph'> (<b>s1</b> ^ <b>s2</b>) returns the intersection of the two <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>sets</font></a> <b>s1</b> and <b>s2</b> that is the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> of <a href='Objects and Entities.html#4611703575761306018'><font color='#'>entities</font></a>
 that belong to both <b>s1</b> and <b>s2</b>.
 Other internal restrictions of the <a href='Selectors_comma Properties and Operations.html#4611703575762381458'><font color='#'>property</font></a> ^ exist, where ^ denotes the intersection
 (it is used for the <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> lattice).</p><a name='4611703575763198706'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='^'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>^(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>y</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> (<b>l</b> ^ <b>y</b>) skips the <b>y</b> first members of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l</b>.
 If the <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a> <b>y</b> is bigger than the <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a> of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l</b>, the result
 is the empty <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>, otherwise it is the sublist starting at the <b>y</b> + 1 position in
 <b>l</b> (up to the <a href='Modules.html#4611703575763160370'><font color='#'>end</font></a>).</p><a name='4611703575763159746'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='add'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>add(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> add(s,<b>x</b>) adds <b>x</b> to the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l</b>. The returned value is the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> obtained by appending (<b>x</b>) to <b>l</b>.</p><a name='4611703575763159682'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='add'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>add(<font color='green'>s</font><font color='blue'>:</font>set, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>set</h3><p align='justify' class='doc_paragraph'> add(<b>s</b>,<b>x</b>) adds <b>x</b> to the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> <b>s</b>. The returned value is the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> <b>s</b> U {<b>x</b>}.
 This <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> may modify the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> <b>s</b> but <a href='Objects and Entities.html#4611703575763393826'><font color='#'>not</font></a> necessarily.</p><a name='4611703575763159938'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='add*'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>add*(<font color='green'>l1</font><font color='blue'>:</font>list, <font color='green'>l2</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> <a href='Classes.html#4611703575763256562'><font color='#'>add</font></a>*(<b>l1</b>,<b>l2</b>) returns the concatenated <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l1</b> . <b>l2</b>, but it is destructive:
 it uses <b>l1</b> as the data structure on which to perform the concatenation.
 Hence, the original <b>l1</b> is no longer available after the <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> <a href='Classes.html#4611703575763256562'><font color='#'>add</font></a>* has been called</p><a name='4611703575763400706'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='car'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>car(<font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>any</h3><p align='justify' class='doc_paragraph'> Classical LISP <a href='Methods.html#4611703575761916626'><font color='#'>methods</font></a> that return the head of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> (e.g. l[1]).
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> car(<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(1,2,3)) -&gt; 1
 car(<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(3,2,1)) -&gt; 3
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763162418'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='cast!'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>cast!(<font color='green'>s</font><font color='blue'>:</font>bag, <font color='green'>t</font><font color='blue'>:</font>type)<font color='blue'> -&gt; </font>bag</h3><p align='justify' class='doc_paragraph'> cast!(<b>s</b>, <b>t</b>) <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>sets</font></a> the <a href='Types.html#4611703575763317762'><font color='#'>member</font></a> <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> of <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> <b>s</b> to <b>t</b>. This <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> should be used carefully since
 their is no verification made to assert that all elements from the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> actually belongs
 to the supplied <a href='Types.html#4611703575761920178'><font color='#'>type</font></a>.
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> cast!(<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(1,2,3), <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a>) -&gt; list&lt;integer&gt;(1,2,3)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763162066'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='cdr'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>cdr(<font color='green'>l</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>type[l]</h3><p align='justify' class='doc_paragraph'> Classical LISP <a href='Methods.html#4611703575761916626'><font color='#'>methods</font></a> that return the tail of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> (e.g. the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l</b> starting at its second element ).
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> cdr(<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(1,2,3)) -&gt; (2, 3)
 cdr(<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(3,2,1)) -&gt; (2, 1)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763163778'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='cons'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>cons(<font color='green'>x</font><font color='blue'>:</font>any, <font color='green'>l</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> This traditional <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> appends <b>x</b> at the beginning of <b>l</b> and returns the constructed <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>.
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> cons(1, <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(2,3)) -&gt; (1,2,3)
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763163954'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='copy'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>copy(<font color='green'>s</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>bag</h3><p align='justify' class='doc_paragraph'> The copy of a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> (a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> or a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>) returns a fresh <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> or <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> with the same elements</p><a name='4611703575763164978'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='delete'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>delete(<font color='green'>s</font><font color='blue'>:</font>bag, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>bag</h3><p align='justify' class='doc_paragraph'> delete(p, <b>x</b>, y) is equivalent to p(<b>x</b>)&nbsp;:delete y. This is a destructive <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> in
 the sense that it modifies its input argument unless the result is <a href='Lists_comma Sets and Tuples.html#4611703575763321282'><font color='#'>nil</font></a>
 (There is only one empty <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>). The proper way to use delete, therefore, is either
 destructive (l&nbsp;:delete <b>x</b>) or non-destructive (delete(<a href='Strings.html#4611703575763164066'><font color='#'>copy</font></a>(l), <b>x</b>)).</p><a name='4611703575763400914'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='difference'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>difference(<font color='green'>self</font><font color='blue'>:</font>set, <font color='green'>x</font><font color='blue'>:</font>set)<font color='blue'> -&gt; </font>set</h3><p align='justify' class='doc_paragraph'> difference(s, t) returns the difference <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> s - t, that is the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>set</font></a> of all elements of
 s which are <a href='Objects and Entities.html#4611703575763393826'><font color='#'>not</font></a> elements of t.</p><a name='4611703575763175538'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='get'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>get(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>integer</h3><p align='justify' class='doc_paragraph'> get(<b>l</b>, <b>x</b>) returns the lowest i such that <b>l</b>[i] = <b>x</b> (if no such i exists, 0 is returned).</p><a name='4611703575763176034'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='hash'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>hash(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>integer</h3><p align='justify' class='doc_paragraph'> hash(<b>l</b>, <b>x</b>) returns an <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a> between 1 and <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>(<b>l</b>) that is obtained through generic hashing.
 To obtain the best dispersion, one may use a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> of size 2i-3. This function can be used to
 implement hash <a href='Tables.html#4611703575762412338'><font color='#'>tables</font></a> in CLAIRE; it is the basis of the <a href='Tables.html#4611703575762412338'><font color='#'>table</font></a> implementation.</p><a name='4611703575763400274'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='last'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>last(<font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>type[member(self)]</h3><p align='justify' class='doc_paragraph'> last(l) returns l[<a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>(l)]</p><a name='4611703575763399586'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='length'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>length(<font color='green'>self</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>integer</h3><p align='justify' class='doc_paragraph'> returns the length of a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>. The length of a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> is <a href='Objects and Entities.html#4611703575763393826'><font color='#'>not</font></a> its size !</p><a name='4611703575763178866'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='list!'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>list!(<font color='green'>s</font><font color='blue'>:</font>set)<font color='blue'> -&gt; </font>type[list[member(s)]]</h3><p align='justify' class='doc_paragraph'> list!(<b>s</b>) transforms <b>s</b> into a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>. The order of the elements in the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> can be anything.</p><a name='4611703575763179506'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='make_list'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i><font color='red'>[XL]</font> Kernel method</i></td>
	</tr></table><h3>make_list(<font color='green'>t</font><font color='blue'>:</font>type, <font color='green'>n</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> returns an empty <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> with <a href='Types.html#4611703575761920178'><font color='#'>type</font></a> <a href='Types.html#4611703575763317762'><font color='#'>member</font></a> <b>t</b>. <b>n</b> gives the size of the
 allocated content (i.e. adding <b>n</b> element won'<b>t</b> cause further allocation).</p><a name='4611703575763179426'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='make_list'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>make_list(<font color='green'>n</font><font color='blue'>:</font>integer, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>type[list[list&lt;any&gt;(x),list({})]]</h3><p align='justify' class='doc_paragraph'> returns a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> of <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a> <b>n</b> filled with <b>x</b> (e.g., make_list(3, 0) = <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(0, 0, 0)).</p><a name='4611703575763399954'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='max'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>max(<font color='green'>f</font><font color='blue'>:</font>method, <font color='green'>self</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>type[member(self)]</h3><p align='justify' class='doc_paragraph'> max(<b>f</b>,<b>self</b>) return the element of <b>self</b> that has the greatest
 value according to the ordering <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> <b>f</b>. For instance&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> max(&lt; @ <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a>, <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(1,2,3,2,1)) -&gt; 3
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763399874'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='min'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i>operation</i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>min(<font color='green'>f</font><font color='blue'>:</font>method, <font color='green'>self</font><font color='blue'>:</font>bag)<font color='blue'> -&gt; </font>type[member(self)]</h3><p align='justify' class='doc_paragraph'> min(<b>f</b>,<b>self</b>) return the element of <b>self</b> that has the lowest
 value according to the ordering <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> <b>f</b>. For instance&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> min(&lt; @ <a href='Integers and Floats.html#4611703575761301906'><font color='#'>integer</font></a>, <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>(1,2,3,2,1)) -&gt; 1
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763321282'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nil'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'></td>
	<td width='20%' align='center'></td><td width='20%' align='right'><i>Core constant</i></td>
	</tr></table><h3>nil<font color='blue'> :: </font>Id(nil)</h3><p align='justify' class='doc_paragraph'> nil is the empty <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> instance.</p><a name='4611703575763157970'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nth'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
			<td  width='20%'></td><td width='20%' align='right'><i>Kernel interface</i></td>
	</tr></table><h3>nth<font color='blue'> :: </font>property(open = 3)</h3><p align='justify' class='doc_paragraph'> nth can be redefined on user <a href='Classes.html#4611703575761317538'><font color='#'>class</font></a> domain meant to have indexed access.
 The reader converts the x[y] notation into a <a href='Calls and Slot Access.html#4611703575763319538'><font color='#'>call</font></a> to nth(x,y) that
 at evaluation will <a href='Calls and Slot Access.html#4611703575763319538'><font color='#'>call</font></a> the redefined restriction&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> hash_table &lt;: ephemeral_object(data:<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>[any])

 nth(x:hash_table, x:any)&nbsp;: any -&gt;
 	x.data[hash_value(x) and \xFFF]
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763183202'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nth'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>nth(<font color='green'>l</font><font color='blue'>:</font>bag, <font color='green'>i</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>any</h3><p align='justify' class='doc_paragraph'> nth(<b>l</b>,<b>i</b>) return the <b>i</b><sup>th</sup>element of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> <b>l</b>.
 nth(<b>l</b>,<b>i</b>) is equivalent to <b>l</b>[<b>i</b>].</p><a name='4611703575763183762'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nth+'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>nth+(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>i</font><font color='blue'>:</font>integer, <font color='green'>x</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>bag</h3><p align='justify' class='doc_paragraph'> <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>+(<b>l</b>,<b>i</b>,<b>x</b>) inserts element <b>x</b> at the <b>i</b><sup>th</sup>position in the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> <b>l</b>.
 By extension, <b>i</b> may be <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>(<b>l</b>) + 1, in which case <b>x</b> is
 inserted at the <a href='Modules.html#4611703575763160370'><font color='#'>end</font></a> of <b>l</b>.</p><a name='4611703575763184034'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nth-'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>nth-(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>i</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>bag</h3><p align='justify' class='doc_paragraph'> nth-(<b>l</b>,<b>i</b>) removes the <b>i</b><sup>th</sup>element of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> <b>l</b>.
 By extension, <b>i</b> may be <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>(<b>l</b>) + 1, in which case x is
 inserted at the <a href='Modules.html#4611703575763160370'><font color='#'>end</font></a> of <b>l</b>.</p><a name='4611703575763400402'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nth='><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>nth=(<font color='green'>self</font><font color='blue'>:</font>list, <font color='green'>x</font><font color='blue'>:</font>integer, <font color='green'>y</font><font color='blue'>:</font>any)<font color='blue'> -&gt; </font>any</h3><p align='justify' class='doc_paragraph'> <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>=(l,i,<b>x</b>) <a href='Strings.html#4611703575763185746'><font color='#'>replace</font></a> the i<sup>th</sup>element of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>bag</font></a> l by <b>x</b>.
 <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>(l,i,<b>x</b>) is equivalent to l[i]&nbsp;:= <b>x</b>.</p><a name='4611703575763159010'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='nth='><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
			<td  width='20%'></td><td width='20%' align='right'><i>Kernel interface</i></td>
	</tr></table><h3>nth=<font color='blue'> :: </font>property(open = 3)</h3><p align='justify' class='doc_paragraph'> <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>= can be redefined on user <a href='Classes.html#4611703575761317538'><font color='#'>class</font></a> domain meant to have indexed access.
 The reader converts the x[y]&nbsp;:= z notation into a <a href='Calls and Slot Access.html#4611703575763319538'><font color='#'>call</font></a> to <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>(x,y,z) that
 at evaluation will <a href='Calls and Slot Access.html#4611703575763319538'><font color='#'>call</font></a> the redefined restriction&nbsp;:
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> hash_table &lt;: ephemeral_object(data:<a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a>[any])

 <a href='Communication ports.html#4611703575763672322'><font color='#'>nth</font></a>=(x:hash_table, x:any, y:any)&nbsp;: void -&gt;
 	x.data[hash_value(x) and \xFFF]&nbsp;:= y
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763400338'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='rmlast'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>rmlast(<font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> removes the <a href='Lists_comma Sets and Tuples.html#4611703575763400274'><font color='#'>last</font></a> element of the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>self</b>.</p><a name='4611703575763190258'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='shrink'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Kernel method</i></td>
	</tr></table><h3>shrink(<font color='green'>l</font><font color='blue'>:</font>list, <font color='green'>n</font><font color='blue'>:</font>integer)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> The <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> shrink truncates the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>l</b> so that its <a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a> becomes <b>n</b>.
 This is a true side-effect and the value returned is always the same as the input.
 As a consequence, shrink(<b>l</b>, 0) returns an empty <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> that is different from the
 canonical empty <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <a href='Lists_comma Sets and Tuples.html#4611703575763321282'><font color='#'>nil</font></a>.
 </p><table class='table_code' align=center border=0 width='85%'>
										<tr><td class='doc_code'> let <b>l</b>&nbsp;:= list&lt;integer&gt;(1,2,3)
 in (shrink(<b>l</b>, 2),
 	assert(<a href='Communication ports.html#4611703575763672482'><font color='#'>length</font></a>(<b>l</b>) = 2))
</td></tr></table>
							  <p align='justify' class='doc_paragraph'></p><a name='4611703575763183250'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='sort'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>sort(<font color='green'>f</font><font color='blue'>:</font>method, <font color='green'>self</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>list</h3><p align='justify' class='doc_paragraph'> this <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> sorts the <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a> <b>self</b> according to the ordering <a href='Methods.html#4611703575761916626'><font color='#'>method</font></a> <b>f</b></p><a name='4611703575763400834'><hr size=0 style='page-break-after: avoid' /></a>
	<a name='tuple!'><hr size=0 /></a>
	<table width='100%' class='item_header'>
		<tr>
			<td width='20%' align='left'><i><a href='claire.index.html#__category_index__'>categories</a></i></td>
			<td width='20%' align='center'><i><a href='Lists_comma Sets and Tuples.html#4611703575761536226'>Lists, Sets and Tuples</a></i></td><td width='20%' align='center'><i>normal dispatch</i></td>
	<td width='20%' align='center'><i></i></td><td width='20%' align='right'><i>Core method</i></td>
	</tr></table><h3>tuple!(<font color='green'>x</font><font color='blue'>:</font>list)<font color='blue'> -&gt; </font>tuple</h3><p align='justify' class='doc_paragraph'> makes a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>tuple</font></a> from a <a href='Lists_comma Sets and Tuples.html#4611703575761536226'><font color='#'>list</font></a></p></body>
	</html>