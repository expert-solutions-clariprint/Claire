
// *********************************************************************
// * CLAIRE                                            Sylvain Benilan *
// * cmdline.cl                                                        *
// * Copyright (C) 2005 xl. All Rights Reserved                        *
// *********************************************************************

//<sb> @cat @xl Command line handling
// @section I/O, Modules and System Interface
// In XL CLAIRE, additionally to the main @ list redefinition, we have
// a command line processor that make a module able to define a particular
// set of option responder and associated command line documentation through
// 2 handlers. For instance the Reader implement the option -f used to load
// a file from the command line. The Reader implements :
// \code
// [option_usage(opt:{"-f", "-ef"}) : tuple(string, string, string) ->
// 	tuple("Load file",
// 			"{-f | -ef} <file:path> ...",
// 			"Load the CLAIRE file(s) <file>. The given path may contain an extension " /+
// 			"assuming .cl by default. When the <-f> option is used, the file is " /+
// 			"assumed to contain CLAIRE definitions (variables, class, methods) whereas " /+
// 			" <-ef> attempts to read a file made of CLAIRE expression.")]
// 	
// 
// [option_respond(opt:{"-f", "-ef"}, l:list) : void ->
// 	if not(l) invalid_option_argument(),
// 	if (not(isfile?(l[1])) & not(isfile?(l[1] /+ ".cl")))
// 		error("~A cannot be opened", l[1]),
// 	while (l & (isfile?(l[1]) | isfile?(l[1] /+ ".cl")))
// 		let path := l[1]
// 		in (l << 1,
// 			case opt
// 				({"-f"} load(path),
// 				{"-ef"} eload(path)))]
// \/code
// It comes with this implementation that when an executable is linked with a set
// of module the whole option set defined by these module is implicitly supported
// by the executable. For instance, when an executable is linked with the Reader
// module is support the -f option.\br
// Additionally to this two handlers, a module can define a single restriction of
// option_parsed that will be called once the full command line has been parsed.
// With such an handler, a module can perform a job that depends on multiple
// independent option responder (that would have initialize global flags). For
// instance :
// \code
// *myopt*:boolean := false
//
// [option_respond(opt:{"myopt"}, l:list) : void -> *myopt* := true]
//
// [option_parsed() : void ->
// 	if *myopt* ...
// 	else ...]
// \/code
// Restrictions of option_usage are used by the command line help which
// is handled with the particular option -h in the Core module :
// \code
// {-h | -help} +[<m> | <option> | <index>]
// \/code
// Which would provide the help for all options defined by a module <m> or for
// a particular option <option> or for the option having the index <index> in
// the option index as generated by option -h when used without arguments.
// @cat

// @doc @xl Command line handling
// A module can define multiple option_respond restrictions that will be called
// by the command line option parser at startup. option_respond will take two
// arguments:
// \code
// option_respond(opt:{"-opt"}, l:list[string]) : void ->
// 	...
// \/code
// \ul
// \li a set constant that contain the option name ("-opt")
// \li a list argument that represent the remaining arguments
// in the command line (where the option as already been removed).
// \/ul
// It is up to the handler to remove used arguments from the given list.
claire/option_respond :: property(open = 3)

// @doc @xl Command line handling
// A module can define a single option_parsed restriction that will be called
// by the command line option parser at startup as soon as the full command
// line is parsed. It will be used inside a module to perform an operation
// that rely on multiple options (for which option_respond as already been called):
// \code
// option_parsed() : void ->
// 	...
// \/code
claire/option_parsed :: property(open = 3)
claire/option_begin_parse :: property(open = 3)

// @doc @xl Command line handling
// A module can define multiple option_usage restrictions that will be called
// by the command line option parser when the command line help is invoked.
// option_usage takes a single argument that is a constant set that contain
// names of multiple related options. The handler should return of tuple of
// 3 strings :
// \ul
// \li A short single line description
// \li The usage syntax of the (set of) option
// \li A detailed description
// \/ul
// \code
// option_usage(opt:{"-opt"}) : tuple(string, string, string) ->
// 	tuple("short description",
// 			"-opt <f:file>", 
// 			"long description on how to use option -opt
// 			we may use <f> to reference the argument f
// 			it can also span multiple line if needed")
// \/code
// The usage should be written following a few guidelines such the command line
// help can produce a description with a nice appearance :
// \ul
// \li <argument> or <argument:domain> is used to describe an argument of the option. As seen
// in the above example we may then use <argument> in the long description as a reference to this
// particular argument.
// \li {...} is used to enclose a non-optional part of the option expression, mostly used if it
// encloses various alternatives
// \li [...] is used to enclose optional part of the option expression
// \li +[...] is used for the repetition one or more time
// \li ...|... (the pipe) is used for possible alternatives
// \/ul
claire/option_usage :: property(open = 3)


// *********************************************************************
// * Part 1: main options usage                                        *
// * Part 2: option help parsing                                       *
// * Part 3: option dispatch                                           *
// *********************************************************************


// *********************************************************************
// * Part 1: main options usage                                        *
// *********************************************************************

option_usage(opt:{"-h","-help"}) : tuple(string, string, string) ->
	tuple("Command line help",
			"{-h | -help} +[<m:module> | <option:string> | <index:integer>]",
			"Display an option index. When <module>, <option> or <index> are given " /+
			"the full help is displayed for the requested entities.")

option_usage(opt:{"-auto", "-s"}) : tuple(string, string, string) ->
	tuple("Memory initialization",
			"[-auto] -s <main:(0 .. 9)> <world:(0 .. 9)>",
			"Sets parameters used to initialize CLAIRE memory. The main/world " /+
			"memory is increased in a chunk of a two exponent of <main>/<world> argument. " /+
			"The main memory is used for normal object allocation and the world " /+
			"memory is used to store defeasible updates.\n" /+
			"When <-auto> is specified the memory is silently allocated to its maximum " /+
			"but still constrained in a chunk as specified by the <-s> option. " /+ 
			"The option <-auto> takes effect around memory congestion (near an overflow) " /+
			"where it let the concerned memory to be silently increased such a program " /+
			"that require more memory (than specified by the <-s> option) can achieve it task. " /+
			"A program ran in <-auto> will take advantage of modern OS that " /+
			"actually manage true virtual pages. The <-auto> flag only controls " /+
			"the memory congestion issue but never perform any de-congestion.")

option_usage(opt:{"-v"}) : tuple(string, string, string) ->
	tuple("Verbose",
			"-v [<m:module>] <level:integer>",
			"Sets the system verbosity level. Any trace instruction with a level " /+
			"lower or equal to <verbose> are issued and others prevented. " /+
			"When <m> is specified the verbosity of the given module is set instead.")

option_usage(opt:{"-q"}) : tuple(string, string, string) ->
	tuple("Exit now",
			"-q [<exitcode:integer>]",
			"Exit now, do not process the end of the command line, do not start an interpreter. " /+
			"When <exitcode> is specified, it is used as the program exit code which is 0 otherwise.\n" /+
			"The <-q> option is always reached even if an exception has occurred before.")

option_usage(opt:{"-qonerror", "-errassegv"}) : tuple(string, string, string) ->
	tuple("Early termination",
			"-qonerror | -errassegv",
			"These options produce an early termination when an uncaught exception occurs. " /+
			"With <-qonerror> the program will exit with code 1 and with <-errassegv> it " /+
			"will raise a segmentation violation signal.")

option_usage(opt:{"-noel"}) : tuple(string, string, string) ->
	tuple("Avoid editline",
			"-noel",
			"Do not use editline for the interpreter.")

option_usage(opt:{"-color", "-nocolor"}) : tuple(string, string, string) ->
	tuple("Terminal color",
			"-color | -nocolor",
			"Enable (or not) the support for terminal colors. Disabled by default.")

option_usage(opt:{"-trace"}) : tuple(string, string, string) ->
	tuple("Trace file",
			"-trace [a | append] <file:path>",
			"Redirect traces to <file>. The file is overwritten unless 'a' or 'append' " /+
			"is specified. Traces depends on the verbosity level (see option <-v>).")


option_usage(opt:{"-sample"}) : tuple(string, string, string) ->
	tuple("Sampling Cmemory",
			"-sample <period:integer>",
			"Perform photos of Cmemory at intervals of <period> milliseconds. " /+
			"A file clmeormy.samples is issued and may be used with gnuplot to " /+
			"produce a graph.")

option_usage(opt:{"-chdir"}) : tuple(string, string, string) ->
	tuple("Change directory",
			"-chdir <dir:relative path>",
			"Change the current working directory to <dir>")


option_usage(opt:{"-options"}) : tuple(string, string, string) ->
	tuple("Load a file of options",
			"-options <cfg:file>",
			"Load file <cfg> containing command line options.")

// *********************************************************************
// * Part 2: option help parsing                                       *
// *********************************************************************

CMD_SEPS :: {"[", "{", "}", "|", "-", "]", "<", " "}
VAR_END :: {">", ":"}
OPT_END :: {" ", "]", "}", "|", "<"}

[print_var(self:string) : void ->
	set_color(32,0),
	princ("<"),
	princ(self),
	princ(">"),
	set_color(30,0)]

[print_option(self:string) : void ->
	let p := port!(self)
	in while not(eof?(p))
		let (o, sep) := freadline(p, {"<"})
		in (set_color(34,0),
			princ(o),
			set_color(30,0),
			case sep
				({"<"} print_var(freadline(p,">"))))]



[print_module(self:module) : void ->
	printf("====== ~S options ======\n", self)]


[parse_var(p:port, opts:list[string], vars:list[string], rngs:list[string]) : string ->
	let (var, sep) := freadline(p, VAR_END)
	in (vars :add var,
		case sep
			({":"}
				let rng := freadline(p, ">")
				in rngs :add rng,
			any rngs :add "unknown"),
		var)]


[parse_option(p:port, opts:list[string], vars:list[string], rngs:list[string]) : void ->
	let opt := "-"
	in while not(eof?(p))
		let (o, sep) := freadline(p, OPT_END)
		in (opt :/+ o,
			case sep
				({"<"}
					opt :/+ "<" /+ parse_var(p, opts, vars, rngs) /+ ">",
				any (opts :add opt,
					print_option(opt),
					princ(sep),
					break())))]

[print_back_option_usage(self:string) : list ->
	let p := port!(self)
	in print_back_option_usage(p)]

[print_back_option_usage(p:port) : list ->
	let vars := list<string>(),
		rngs := list<string>(),
		opts := list<string>()
	in (while not(eof?(p))
		let (dummy, sep) := freadline(p, CMD_SEPS)
		in (princ(dummy),
			case sep
				({"[", "]", "|", "{", "}"} princ(sep),
				{"-"} (if (length(dummy) > 0) princ("-")
				       else parse_option(p, opts, vars, rngs)),
				{"<"} print_var(parse_var(p, opts, vars, rngs)),
				{" "} princ(" "))),
		list(opts,vars,rngs))]
						

[print_back_option_help(self:string, l:list) : void ->
	let p := port!(self)
	in print_back_option_help(p, l)]

[print_back_option_help(p:port, l:list) : void ->
	princ("    "),
	while not(eof?(p))
		let (data, sep) := freadline(p, {"<","\n"})
		in (color_princ(data),
			if (sep = "\n") princ("\n    ")
			else if not(eof?(p))
				let varopt := freadline(p, ">")
				in (if (varopt % l[1])
						print_option(varopt)
					else print_var(varopt)))]

[find_option_usage(self:integer) : (method  U {unknown}) ->
	let l := option_usage.restrictions,
		idx := 0,
		good := unknown
	in (for m in module
			(if known?(good) break(),
			for r in list{r in l| r.module! = m}
				(idx :+ 1,
				if (idx = self)
					(good := r,
					break()))), good as (method  U {unknown}))]

[find_option_usage(self:string) : (method  U {unknown}) ->
	some(r in option_usage.restrictions |
			exists(w in r.domain[1] | match_wildcard?(self, w))) as
				(method  U {unknown})]


[print_option_usage(r:method, m:module) : void ->
	let (title, syntax, help) := apply(r, list(r.domain[1][1]))
	in (printf("  ", m),
		let l := print_back_option_usage(syntax)
		in (princ("\n"),
			if (length(l[2]) > 0)
				(for i in (1 .. length(l[2]))
					(if not(exists(j in (1 .. i - 1) | l[2][i] = l[2][j]))
						printf("    ~I % ~A\n", print_var(l[2][i]), l[3][i]))),
			princ("\n"),
			print_back_option_help(help, l),
			princ("\n\n")))]

[print_option_usage(r:method) : void ->
	print_option_usage(r, r.module!)]

[print_option_usage(opt:string) : void ->
	when r := find_option_usage(opt)
	in print_option_usage(r)
	else printf("`REDInvalid option ~S\n", opt)]

[print_option_usage(m:module) : void ->
	for r in list{r in option_usage.restrictions | r.module! = m}
		print_option_usage(r, m)]

[print_option_usage() : void ->
	for m in module
		let first? := true
		in for r in list{r in option_usage.restrictions | r.module! = m}
				(if first?
					(first? := false,
					print_module(m)),
				print_option_usage(r, m))]


[print_option_index(r:method, i:integer) : void ->
	let (title, syntax, help) := apply(r, list(r.domain[1][1]))
	in printf("~I - ~A : ~I\n",
				(set_color(32,0),print(i),set_color(30,0)),
				title,
				print_back_option_usage(syntax))]


[print_option_index() : void ->
	printf("====== Option syntax ======\n"),
	printf("  ``BLACK[`BLACKx``BLACK]\t`BLACK-> x is optional\n"),
	printf("  ``BLACK{`BLACKx``BLACK}\t`BLACK-> x (identity)\n"),
	printf("  x ``BLACK| `BLACKy\t-> x or y\n"),
	printf("  ``BLACK+`BLACKx\t-> x is repeated at least one\n"),
	printf("  ``BLACK*`BLACKx\t-> x is repeated 0 or more times\n"),
	let l := option_usage.restrictions,
		idx := 0
	in for m in module
		let first? := true
		in for r in list{r in l| r.module! = m}
			(idx :+ 1,
			if first?
				(print_module(m),
				first? := false),
			print_option_index(r, idx))]


[apply_option_begin_parse() : void ->
	for r in option_begin_parse.restrictions
		apply(r, list(void))]

[apply_option_parsed() : void ->
	for r in option_parsed.restrictions
		apply(r, list(void))]

claire/invalid_option_argument <: exception()

[option_respond(opt:{"-h", "-help"}, l:list) : void ->
	color(1),
	if not(l) print_option_index()
	else while l
		let opt := l[1],
			lopt := lower(opt),
			mod := some(m in module | lower(m.name.name) = lopt)
		in (case mod
			(module
				(printf("====== [~S] ======\n\n", mod),
				if mod.made_of
					print_option_usage(mod)
				else for m in mod.parts
					print_option_usage(m)),
			any
				when r := find_option_usage(opt)
				in print_option_usage(r)
				else when r := find_option_usage(integer!(opt))
					in print_option_usage(r)
					else printf("`RED~A is unbound (try ~A -h)\n", opt, params()[1])),
			l << 1), exit(0)]

[option_respond(opt:{"-s"}, l:list) : void -> l << 2]

%qonerror:boolean := false
%errassegv:boolean := false

[option_respond(opt:{"-color","-nocolor","-logo","-auto","-noel","-alt","-gcstress"}, l:list) : void -> none]
[option_respond(opt:{"-qonerror"}, l:list) : void -> %qonerror := true]
[option_respond(opt:{"-errassegv"}, l:list) : void -> %errassegv := true]


number?(s:string) : boolean ->
	(if digit?(s) true
	else if (length(s) < 2) false
	else if (s[1] != '-') false
	else digit?(substring(s, 2, length(s))))
		

[option_respond(opt:{"-q"}, l:list) : void ->
	let l1 := (if l l[1] else "")
	in (apply_option_parsed(),
		exit(integer!(l1)))]

[option_respond(opt:{"-v"}, l:list) : void ->
	if not(l) invalid_option_argument(),
	let opt := l[1],
		mod := get_value(opt),
		v := integer!(opt)
	in case mod
		(module
			(l << 1,
			if (not(l) | not(number?(l[1])))
				invalid_option_argument(),
			mod.verbose := integer!(l[1]),
			l << 1),
		any
			(if not(number?(l[1]))
				invalid_option_argument(),
			l << 1,
			verbose() := integer!(opt)))]

[option_respond(opt:{"-trace"}, l:list) : void ->
	let m := "w"
	in (if not(l) invalid_option_argument(),
		case l[1]
			({"a", "append"}
				(m := "a",
				l << 1,
				if not(l) invalid_option_argument())),
	  let path := l[1]
		in (l << 1,
		    ctrace() := fopen(path, m)))]

[option_respond(opt:{"-sample"}, l:list) : void ->
	if not(l) invalid_option_argument(),
	l << 1]


option_respond(opt:{"-chdir"}, l:list[string]) : void ->
	(if not(l) invalid_option_argument(),
	let dir := l[1]
	in (l << 1,
		setcwd(dir)))

DYNLOADS:list[string] := list<string>()

[option_respond(opt:{"-dynload"}, l:list[string]) : void ->
  if not(l) invalid_option_argument(),
	let m := l[1],
	    ext := ".dll"
	in (if Core/unix?()
	      ext := ".so"
	    else m := replace(m, "/", *fs*),
	    m := replace(replace(m, ".so", ""), ".dll", ""),
	    let mname := last(explode(m, *fs*))
    	in (l << 1,
    	   DYNLOADS add realpath(m /+ ext),
    		 dload(mname, m /+ ext)))]

[option_usage(self:{"-dynload"}) : tuple(string, string, string) ->
  tuple("Load module dynamically",
      "-dynload <m:dll/so>",
      "Loads module identified by the file <m> dynamically, the file extension " /+
      "can be omitted it would be set automatically to .dll or .so depending on " /+
      "the host platform.")]


// *********************************************************************
// * Part 3: option dispatch                                           *
// *********************************************************************


toplevel :: property(open = 3)

print_cmline_exception() : void ->
	(if (get_value("Reader") % module)
		let p := get_value(get_value("Reader"), "print_exception")
		in funcall(p.restrictions[1].functional, any, system, void)
	else
		(externC("avoid_signal_handling++"),
		let p := use_as_output(stdout),
			 %err := system.exception!,
			 %prop := ((self_print @ owner(%err)) as method) in
		   (try (set_color(31,0),
				if known?(functional, %prop)
				funcall(%prop.functional, object, %err, any)
			 else funcall(%prop, %err),
			 princ("\n"))
			catch any
				(set_color(31,0),
				printf("\n[121] unprintable error <~S>.\n", owner(%err))),
		  set_color(30,0),
		  use_as_output(p),
		  externC("avoid_signal_handling--"))))


//<sb> v3.3.35 this is our new entry point
[parse_command_line() : void ->
	if unix?() //<sb> setup "_"
		let prog := params()[1]
		in (if (match_wildcard?(prog,"./*") |
					match_wildcard?(prog,"/*") |
					match_wildcard?(prog,"../*"))
				setenv("_=" /+ prog)
			else let paths := explode(getenv("PATH"), ":")
				in for p in paths
					(if ((try prog % entries(p) catch any false) &
							isfile?(p / prog))
						(setenv("_=" /+ p / prog),
						break()))),
	let argv := copy(params())
	in (argv << 1,
	    apply_command_line(argv, true))]

claire/on_option_error :: property(open = 3)

[apply_command_line(argv:list[string], exit?:boolean) : void ->
	let cmd_line_err? := false
	in (try
			(if exit? apply_option_begin_parse(),
			while argv
				let opt := argv[1]
				in (argv << 1,
					try
						(when r := some(r in option_respond.restrictions |
									exists(w in r.domain[1] | match_wildcard?(opt, w)))
						in apply(r, list(opt, argv))
						else
							error("Invalid option ~A (try ~A -h)\n", opt, params()[1]))
					catch invalid_option_argument
						(for x in on_option_error.restrictions
  		        apply(x, list(opt)),
            color(1),
						print_option_usage(opt),
						if argv
							printf("`REDInvalid argument ~A for option ~A\n", argv[1], opt)
						else
							printf("`REDMissing argument for option ~A\n", opt),
						if not(exit?) close(exception!()),
						exit(1))),
			if exit? apply_option_parsed())
		catch any
			(if not(exit?) close(exception!()),
			cmd_line_err? := true,
			for x in on_option_error.restrictions
  		  apply(x, list(void)),
  		if %qonerror
				(color(1),
				printf("`RED-qonerror handled by exception:\n~I", print_cmline_exception()),
				exit(1))
			else if ("-q" % params())
				(printf("`RED-q handled by exception:\n~I", print_cmline_exception()),
				exit(1)),
			print_cmline_exception()),
		if exit?
  		(if (toplevel.restrictions & externC("TOPLEVEL ? CTRUE : CFALSE", boolean))
  			(color(1),
  			toplevel()),
  		if cmd_line_err? exit(1)
  		else exit(0)))]


[option_respond(opt:{"-source-editor"}, l:list) : void ->
	if l
		(setenv("WCL_EDITOR=" /+ l[1]),
		l << 1)]

[option_respond(opt:{"-source-edit"}, l:list) : void ->
	if l open_link(l[1])
	else invalid_option_argument(),
	exit(0)]

OPTION_LINE:integer := 0
OPTION_PATH:string := ""

[read_cmd_string(b:port, eos:string) : string ->
  let p := blob!()
  in (while not(eof?(b))
        let (s, sep) := freadline(b, set<string>("\\n", "\\t", "\\r", "\\\"", "\\\\", eos))
        in (fwrite(s,p),
            case sep
              ({""} error("Premature end of string."),
              {"\\n"} (fwrite("\n", p)),
              {"\\r"} fwrite("\r", p),
              {"\\t"} fwrite("\t", p),
              {"\\\""} fwrite("\"", p),
              {"\\\\"} fwrite("\\", p),
              any break())),
      let s := string!(p)
      in (fclose(p),
          s))]

[claire/shell_expand(s:string) : string ->
  let b := blob!(s),
      res := blob!()
  in (while not(eof?(b))
        let (data, sep) := freadline(b, {"$("})
        in (fwrite(data, res),
            if (sep = "$(")
              fwrite(getenv(freadline(b, ")")), res)),
      fclose(b),
      s := string!(res),
      fclose(res),
      s)]

[read_option_line(f:port, opts:list[string]) : void ->
  while not(eof?(f))
    let (s, sep) := freadline(f, {"'", " ", "\n", "\r", "\t", "%", "#", "\\"})
    in (if (sep = "'")
          (if (s != "")
            error("Error handling option file ~A:~S\nseparation missing between ~S and ~S", OPTION_PATH, OPTION_LINE, s, sep),
          s := freadline(f, "'"))
        else s := shell_expand(s),
        if (s != "")
          (if not(opts) opts add ("-" /+ s)
          else opts add s),
        if (sep = "\\")
          (freadline(f),
          OPTION_LINE :+ 1),
        if (sep = "%" | sep = "#")
          (freadline(f),
          sep := "\n"),
        if (sep = "\n")
          OPTION_LINE :+ 1,
        if (sep % {"\n", ""} & opts)
          break())]

option_instruction <: ephemeral_object(
      filename:string,
      line:integer)

  option_apply <: option_instruction(args:list[string])

  option_do <: option_instruction(args:list[option_instruction])

    option_if <: option_do(
      test:string,
      other:option_instruction)
      
    option_while <: option_do(
      test:string)

    option_for <: option_do(
      forvar:string,
      forsetarg:string,
      such:string = "")

[close(self:option_instruction) : option_instruction ->
  self.line := OPTION_LINE,
  self.filename := OPTION_PATH,
  self]

[read_option_file(b:port, ado:option_do) : void ->
  while not(eof?(b))
  	let opts := list<string>()
  	in (read_option_line(b, opts),
  	    if opts
  	      case opts[1]
  	        ({"-end"} break(),
  	        {"-while"} ado.args add read_option_while(b, opts),
  	        {"-for"} ado.args add read_option_for(b, opts),
  	        {"-if"} ado.args add read_option_if(b, opts),
  	        {"-elif"}
  	          (case ado
  	            (option_if
  	              (ado.other := read_option_if(b, opts),
  	              break()),
  	            any error("Syntax error near 'elif'"))),
  	        {"-else"}
  	          (if (length(opts) != 1)
  	            invalid_option_argument(),
  	          case ado
  	            (option_if
  	              (ado.other := option_do(),
  	              read_option_file(b, ado.other),
  	              break()),
  	            any error("Syntax error near 'else'"))),
  	        any ado.args add option_apply(args = opts)))]


[read_option_if(b:port, opts:list[string]) : option_if ->
  if (length(opts) != 2) invalid_option_argument(),
  let x := option_if(test = opts[2])
  in (read_option_file(b, x),
      x)]

[read_option_while(b:port, opts:list[string]) : option_while ->
  if (length(opts) != 2) invalid_option_argument(),
  let x := option_while(test = opts[2])
  in (read_option_file(b, x),
      x)]

[read_option_for(b:port, opts:list[string]) : option_for ->
  if (length(opts) < 3 | length(opts) > 4) invalid_option_argument(),
  let x := option_for(forvar = opts[2], forsetarg = opts[3])
  in (if (length(opts) = 4) x.such := opts[4],
      read_option_file(b, x),
      x)]

[eval_options(self:option_apply) : void ->
  OPTION_LINE := self.line,
  apply_command_line(copy(self.args), false)]

claire/option_push :: property(open = 3)
claire/option_test :: property(open = 3)
claire/option_pop :: property(open = 3)
claire/option_continue? :: property(open = 3)
claire/option_start_loop :: property(open = 3)

[eval_options(self:option_do) : void ->
  OPTION_LINE := self.line,
  option_push(),
  for x in self.args
    eval_options(x),
  option_pop()]

[eval_options(self:option_if) : void ->
  OPTION_LINE := self.line,
  if option_test(self.test)
    (option_push(),
    for x in self.args
      eval_options(x),
    option_pop())
  else if known?(other, self)
    eval_options(self.other)]

[eval_options(self:option_while) : void ->
  OPTION_LINE := self.line,
  while option_test(self.test)
    (option_push(),
    for x in self.args
      eval_options(x),
    option_pop(),
    OPTION_LINE := self.line)]

[eval_options(self:option_for) : void ->
  OPTION_LINE := self.line,
  let ctx := option_start_loop(self.forvar, self.forsetarg, self.such)
  in while option_continue?(ctx)
    (option_push(),
    for x in self.args
      eval_options(x),
    option_pop(),
    OPTION_LINE := self.line)]


[option_respond(opt:{"-options"}, l:list) : void ->
	if not(l) invalid_option_argument(),
	if not(isfile?(l[1])) invalid_option_argument(),
	let path := l[1],
	    f := fopen(path, "r"), // do not keep option file opened
	    oldl := OPTION_LINE,
	    oldp := OPTION_PATH
	in (l << 1,
	    OPTION_LINE := 0,
	    OPTION_PATH := path,
	    try (let ado := option_do()
	        in (while not(eof?(f))
	              read_option_file(f, ado),
	            fclose(f),
	            for x in ado.args
	              eval_options(x)),
	        OPTION_LINE := oldl,
	        OPTION_PATH := oldp)
  	  catch any
  	    error("Error handling option file ~A:~S\n~S\n", path, OPTION_LINE, exception!()))]

/*
[option_respond(opt:{"-options"}, l:list) : void ->
	if not(l) invalid_option_argument(),
	if not(isfile?(l[1])) invalid_option_argument(),
	let path := l[1],
	    f := fopen(path, "r"),
	    opts := list<string>(),
	    line := 1
	in (l << 1,
	    while not(eof?(f))
	      let (s, sep) := freadline(f, {"'", "\"", " ", "\n", "\r", "\t", "%"})	          
	      in (try
  	          (if (sep % {"'", "\""})
  	            (if (s != "")
  	              error("Error handling option file ~A:~S\nseparation missing between ~S and ~S", path, line, s, sep),
  	            s := read_cmd_string(f, sep)),  	            
  	          if (s != "")
  	            (if not(opts) opts add ("-" /+ s)
  	            else opts add s),
  	          if (sep = "%")
  	            (freadline(f),
  	            sep := "\n"),
  	          if (sep % {"\n", ""} & opts)
  	            (apply_command_line(opts, false),
  	            shrink(opts, 0)),
  	          if (sep = "\n") line :+ 1)
  	        catch any
  	          error("Error handling option file ~A:~S\n~S\n", path, line, exception!())))]
*/
[open_link(url:string) : void ->
	let parms :=
			(let expl := explode_wildcard(url, "claire://source-edit#?file=*&line=*&editor=*")
			in (if (length(expl) = 0) expl := explode_wildcard(url, "claire://source-edit/#?file=*&line=*&editor=*"),
			    if (length(expl) = 0) expl := explode_wildcard(url, "claire://source-edit#?file=*&line=*&editor=*"),  
				  expl)),
		cmd := blob!()
	in (if (length(getenv("WCL_EDITOR")) > 0)
	      fwrite(getenv("WCL_EDITOR"), cmd)
	    else if (length(parms) >= 3 & length(parms[3]) > 0)
	      fwrite(url_decode(parms[3]), cmd),
	    try
			(print_in_string(),
			while not(eof?(cmd))
				let (data, sep) := freadline(cmd, {"$(FILE::", "$(FILE)", "$(LINE)"})
				in (princ(data),
					case sep
						({"$(LINE)"}
							(if (length(parms) >= 2) princ(parms[2])
							else princ(1)),
						{"$(FILE)"}
							(if (length(parms) >= 1) princ(url_decode(parms[1]))),
						{"$(FILE::"}
							let bases := list<string>(),
								reps := list<string>()
							in (while not(eof?(cmd))
									(bases add freadline(cmd,"::"),
									let (rep, e) := freadline(cmd,{"::", ")"})
									in (reps add rep,
										if (e != "::") break())),
								if (length(parms) >= 1)
									let bs := "", idx := 0, bsidx := 0,
										str := url_decode(parms[1])
									in (for e in bases
											(idx :+ 1,
											if (find(str, e) = 1 & length(e) > length(bs))
												(bsidx := idx,
												bs := e)),
										if (bsidx > 0)
											princ(replace(str, bs, reps[bsidx]))
										else princ(str))))),
			shell(end_of_string()))
		catch any none)]
	

[edit_link(b:bag) : void ->
	if (length(b) >= 2 & b[1] % string & b[2] % integer)
		printf("<a href='claire://source-edit?file=~A&line=~S&editor=~A'>~A:~S</a>",
			url_encode(b[1]),
			b[2],
			url_encode(getenv("WCL_EDITOR")),
			b[1], b[2])
	else if (length(b) >= 1 & b[1] % string)
		printf("<a href='claire://source-edit?file=~A&line=1&editor=~A'>~A</a>",
			url_encode(b[1]),
			url_encode(getenv("WCL_EDITOR")),
			b[1])]

[edit_link(src:string, l:integer, s:string) : void ->
	printf("<a href='claire://source-edit?file=~A&line=~S&editor=~A'>~A</a>",
			url_encode(src),
			l,
			url_encode(getenv("WCL_EDITOR")),
			s)]

